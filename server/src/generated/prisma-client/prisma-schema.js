module.exports = {
  // Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
  typeDefs:
    // Please don't change this file manually but run `prisma generate` to update it.
    // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

    /* GraphQL */ `
      type AggregateProject {
        count: Int!
      }

      type AggregateUser {
        count: Int!
      }

      type BatchPayload {
        count: Long!
      }

      scalar DateTime

      scalar Long

      type Mutation {
        createProject(data: ProjectCreateInput!): Project!
        updateProject(
          data: ProjectUpdateInput!
          where: ProjectWhereUniqueInput!
        ): Project
        updateManyProjects(
          data: ProjectUpdateManyMutationInput!
          where: ProjectWhereInput
        ): BatchPayload!
        upsertProject(
          where: ProjectWhereUniqueInput!
          create: ProjectCreateInput!
          update: ProjectUpdateInput!
        ): Project!
        deleteProject(where: ProjectWhereUniqueInput!): Project
        deleteManyProjects(where: ProjectWhereInput): BatchPayload!
        createUser(data: UserCreateInput!): User!
        updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
        updateManyUsers(
          data: UserUpdateManyMutationInput!
          where: UserWhereInput
        ): BatchPayload!
        upsertUser(
          where: UserWhereUniqueInput!
          create: UserCreateInput!
          update: UserUpdateInput!
        ): User!
        deleteUser(where: UserWhereUniqueInput!): User
        deleteManyUsers(where: UserWhereInput): BatchPayload!
      }

      enum MutationType {
        CREATED
        UPDATED
        DELETED
      }

      interface Node {
        id: ID!
      }

      type PageInfo {
        hasNextPage: Boolean!
        hasPreviousPage: Boolean!
        startCursor: String
        endCursor: String
      }

      type Project {
        id: ID!
        createdAt: DateTime!
        updatedAt: DateTime!
        name: String!
        description: String!
        validation: Int!
        bucketUrl: String!
        category: String!
        currentJobId: String
        type: ProjectType
        repeatable: Boolean
        question: String
        classes: [String!]!
        width: Int
        height: Int
      }

      type ProjectConnection {
        pageInfo: PageInfo!
        edges: [ProjectEdge]!
        aggregate: AggregateProject!
      }

      input ProjectCreateclassesInput {
        set: [String!]
      }

      input ProjectCreateInput {
        id: ID
        name: String!
        description: String!
        validation: Int!
        bucketUrl: String!
        category: String!
        currentJobId: String
        type: ProjectType
        repeatable: Boolean
        question: String
        classes: ProjectCreateclassesInput
        width: Int
        height: Int
      }

      type ProjectEdge {
        node: Project!
        cursor: String!
      }

      enum ProjectOrderByInput {
        id_ASC
        id_DESC
        createdAt_ASC
        createdAt_DESC
        updatedAt_ASC
        updatedAt_DESC
        name_ASC
        name_DESC
        description_ASC
        description_DESC
        validation_ASC
        validation_DESC
        bucketUrl_ASC
        bucketUrl_DESC
        category_ASC
        category_DESC
        currentJobId_ASC
        currentJobId_DESC
        type_ASC
        type_DESC
        repeatable_ASC
        repeatable_DESC
        question_ASC
        question_DESC
        width_ASC
        width_DESC
        height_ASC
        height_DESC
      }

      type ProjectPreviousValues {
        id: ID!
        createdAt: DateTime!
        updatedAt: DateTime!
        name: String!
        description: String!
        validation: Int!
        bucketUrl: String!
        category: String!
        currentJobId: String
        type: ProjectType
        repeatable: Boolean
        question: String
        classes: [String!]!
        width: Int
        height: Int
      }

      type ProjectSubscriptionPayload {
        mutation: MutationType!
        node: Project
        updatedFields: [String!]
        previousValues: ProjectPreviousValues
      }

      input ProjectSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: ProjectWhereInput
        AND: [ProjectSubscriptionWhereInput!]
        OR: [ProjectSubscriptionWhereInput!]
        NOT: [ProjectSubscriptionWhereInput!]
      }

      enum ProjectType {
        CLASS
        BINARY
      }

      input ProjectUpdateclassesInput {
        set: [String!]
      }

      input ProjectUpdateInput {
        name: String
        description: String
        validation: Int
        bucketUrl: String
        category: String
        currentJobId: String
        type: ProjectType
        repeatable: Boolean
        question: String
        classes: ProjectUpdateclassesInput
        width: Int
        height: Int
      }

      input ProjectUpdateManyMutationInput {
        name: String
        description: String
        validation: Int
        bucketUrl: String
        category: String
        currentJobId: String
        type: ProjectType
        repeatable: Boolean
        question: String
        classes: ProjectUpdateclassesInput
        width: Int
        height: Int
      }

      input ProjectWhereInput {
        id: ID
        id_not: ID
        id_in: [ID!]
        id_not_in: [ID!]
        id_lt: ID
        id_lte: ID
        id_gt: ID
        id_gte: ID
        id_contains: ID
        id_not_contains: ID
        id_starts_with: ID
        id_not_starts_with: ID
        id_ends_with: ID
        id_not_ends_with: ID
        createdAt: DateTime
        createdAt_not: DateTime
        createdAt_in: [DateTime!]
        createdAt_not_in: [DateTime!]
        createdAt_lt: DateTime
        createdAt_lte: DateTime
        createdAt_gt: DateTime
        createdAt_gte: DateTime
        updatedAt: DateTime
        updatedAt_not: DateTime
        updatedAt_in: [DateTime!]
        updatedAt_not_in: [DateTime!]
        updatedAt_lt: DateTime
        updatedAt_lte: DateTime
        updatedAt_gt: DateTime
        updatedAt_gte: DateTime
        name: String
        name_not: String
        name_in: [String!]
        name_not_in: [String!]
        name_lt: String
        name_lte: String
        name_gt: String
        name_gte: String
        name_contains: String
        name_not_contains: String
        name_starts_with: String
        name_not_starts_with: String
        name_ends_with: String
        name_not_ends_with: String
        description: String
        description_not: String
        description_in: [String!]
        description_not_in: [String!]
        description_lt: String
        description_lte: String
        description_gt: String
        description_gte: String
        description_contains: String
        description_not_contains: String
        description_starts_with: String
        description_not_starts_with: String
        description_ends_with: String
        description_not_ends_with: String
        validation: Int
        validation_not: Int
        validation_in: [Int!]
        validation_not_in: [Int!]
        validation_lt: Int
        validation_lte: Int
        validation_gt: Int
        validation_gte: Int
        bucketUrl: String
        bucketUrl_not: String
        bucketUrl_in: [String!]
        bucketUrl_not_in: [String!]
        bucketUrl_lt: String
        bucketUrl_lte: String
        bucketUrl_gt: String
        bucketUrl_gte: String
        bucketUrl_contains: String
        bucketUrl_not_contains: String
        bucketUrl_starts_with: String
        bucketUrl_not_starts_with: String
        bucketUrl_ends_with: String
        bucketUrl_not_ends_with: String
        category: String
        category_not: String
        category_in: [String!]
        category_not_in: [String!]
        category_lt: String
        category_lte: String
        category_gt: String
        category_gte: String
        category_contains: String
        category_not_contains: String
        category_starts_with: String
        category_not_starts_with: String
        category_ends_with: String
        category_not_ends_with: String
        currentJobId: String
        currentJobId_not: String
        currentJobId_in: [String!]
        currentJobId_not_in: [String!]
        currentJobId_lt: String
        currentJobId_lte: String
        currentJobId_gt: String
        currentJobId_gte: String
        currentJobId_contains: String
        currentJobId_not_contains: String
        currentJobId_starts_with: String
        currentJobId_not_starts_with: String
        currentJobId_ends_with: String
        currentJobId_not_ends_with: String
        type: ProjectType
        type_not: ProjectType
        type_in: [ProjectType!]
        type_not_in: [ProjectType!]
        repeatable: Boolean
        repeatable_not: Boolean
        question: String
        question_not: String
        question_in: [String!]
        question_not_in: [String!]
        question_lt: String
        question_lte: String
        question_gt: String
        question_gte: String
        question_contains: String
        question_not_contains: String
        question_starts_with: String
        question_not_starts_with: String
        question_ends_with: String
        question_not_ends_with: String
        width: Int
        width_not: Int
        width_in: [Int!]
        width_not_in: [Int!]
        width_lt: Int
        width_lte: Int
        width_gt: Int
        width_gte: Int
        height: Int
        height_not: Int
        height_in: [Int!]
        height_not_in: [Int!]
        height_lt: Int
        height_lte: Int
        height_gt: Int
        height_gte: Int
        AND: [ProjectWhereInput!]
        OR: [ProjectWhereInput!]
        NOT: [ProjectWhereInput!]
      }

      input ProjectWhereUniqueInput {
        id: ID
      }

      type Query {
        project(where: ProjectWhereUniqueInput!): Project
        projects(
          where: ProjectWhereInput
          orderBy: ProjectOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Project]!
        projectsConnection(
          where: ProjectWhereInput
          orderBy: ProjectOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): ProjectConnection!
        user(where: UserWhereUniqueInput!): User
        users(
          where: UserWhereInput
          orderBy: UserOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [User]!
        usersConnection(
          where: UserWhereInput
          orderBy: UserOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): UserConnection!
        node(id: ID!): Node
      }

      type Subscription {
        project(
          where: ProjectSubscriptionWhereInput
        ): ProjectSubscriptionPayload
        user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
      }

      type User {
        id: ID!
        email: String!
        password: String!
        name: String!
      }

      type UserConnection {
        pageInfo: PageInfo!
        edges: [UserEdge]!
        aggregate: AggregateUser!
      }

      input UserCreateInput {
        id: ID
        email: String!
        password: String!
        name: String!
      }

      type UserEdge {
        node: User!
        cursor: String!
      }

      enum UserOrderByInput {
        id_ASC
        id_DESC
        email_ASC
        email_DESC
        password_ASC
        password_DESC
        name_ASC
        name_DESC
      }

      type UserPreviousValues {
        id: ID!
        email: String!
        password: String!
        name: String!
      }

      type UserSubscriptionPayload {
        mutation: MutationType!
        node: User
        updatedFields: [String!]
        previousValues: UserPreviousValues
      }

      input UserSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: UserWhereInput
        AND: [UserSubscriptionWhereInput!]
        OR: [UserSubscriptionWhereInput!]
        NOT: [UserSubscriptionWhereInput!]
      }

      input UserUpdateInput {
        email: String
        password: String
        name: String
      }

      input UserUpdateManyMutationInput {
        email: String
        password: String
        name: String
      }

      input UserWhereInput {
        id: ID
        id_not: ID
        id_in: [ID!]
        id_not_in: [ID!]
        id_lt: ID
        id_lte: ID
        id_gt: ID
        id_gte: ID
        id_contains: ID
        id_not_contains: ID
        id_starts_with: ID
        id_not_starts_with: ID
        id_ends_with: ID
        id_not_ends_with: ID
        email: String
        email_not: String
        email_in: [String!]
        email_not_in: [String!]
        email_lt: String
        email_lte: String
        email_gt: String
        email_gte: String
        email_contains: String
        email_not_contains: String
        email_starts_with: String
        email_not_starts_with: String
        email_ends_with: String
        email_not_ends_with: String
        password: String
        password_not: String
        password_in: [String!]
        password_not_in: [String!]
        password_lt: String
        password_lte: String
        password_gt: String
        password_gte: String
        password_contains: String
        password_not_contains: String
        password_starts_with: String
        password_not_starts_with: String
        password_ends_with: String
        password_not_ends_with: String
        name: String
        name_not: String
        name_in: [String!]
        name_not_in: [String!]
        name_lt: String
        name_lte: String
        name_gt: String
        name_gte: String
        name_contains: String
        name_not_contains: String
        name_starts_with: String
        name_not_starts_with: String
        name_ends_with: String
        name_not_ends_with: String
        AND: [UserWhereInput!]
        OR: [UserWhereInput!]
        NOT: [UserWhereInput!]
      }

      input UserWhereUniqueInput {
        id: ID
        email: String
      }
    `,
}
